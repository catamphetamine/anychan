import parseAuthor from './parseAuthor'
import parseAuthorRole from './parseAuthorRole'
import parseAttachments from './parseAttachments'

// Фраза "Абу благословил этот пост" добавляется в конец поста
// если этот пост отправлен с использованием "пасс-кода"
// и содержит слово "Спасибо" (с большой буквы).
// Видимо, это задумывалось как способ идентификации автором поста
// себя как "пасскодобоярина" (то есть, чтобы козырнуть своим статусом).
const ABU_LIKE = /<br><br><span class="thanks-abu" style="color: red;">Абу благословил этот пост\.<\/span>$/

const MAILTO = /^mailto:/

/**
 * Parses response thread JSON object.
 * @param  {object} thread — Response thread JSON object.
 * @param  {object} options
 * @param  {object} data
 * @return {object} See README.md for "Comment" object description.
 */
export default function parseComment(post, {
	boardId,
	toAbsoluteUrl
}, {
	defaultAuthorName,
	hasVoting,
	hasFlags,
	badges
}) {
	let title = post.subject
	// `post.comment` is always present, even when there's no text.
	let content = post.comment
	// Remove "Абу благословил этот пост" footer.
	let abuLike = false
	if (ABU_LIKE.test(content)) {
		abuLike = true
		content = content.replace(ABU_LIKE, '')
	}
	const id = parseInt(post.num)
	const threadId = parseInt(post.parent)
	const isOpeningPost = threadId === 0
	// Detect `subject` being autogenerated from `comment`.
	// (for example, on `/b/` and `/rf/` boards)
	// If the `title` is autogenerated then ignore it.
	if (title && isOpeningPost) {
		if (isAutogeneratedSubject(title, content)) {
			title = undefined
		}
	}
	const author = parseAuthor(post.name, { defaultAuthorName, boardId })
	const comment = {
		boardId,
		threadId: isOpeningPost ? id : threadId,
		id,
		title,
		content,
		authorName: author && (typeof author === 'string' ? author : author.name),
		authorRole: parseAuthorRole(post.trip),
		authorBan: post.banned === 1,
		attachments: parseAttachments(post, { toAbsoluteUrl }),
		createdAt: new Date(post.timestamp * 1000)
	}
	if (author && typeof author === 'object') {
		// Author name is an equivalent of author id.
		comment.authorNameId = true
		comment.authorId = author.id
		comment.authorIdColor = author.color
	}
	if (post.email) {
		// "mailto:admin@example.com" -> "admin@example.com".
		const email = post.email.replace(MAILTO, '')
		// Some users write "Sage" instead of "sage".
		// I guess those are mobile users with `<input type="text"/>` autocapitalization.
		if (email === 'sage' || email === 'Sage') {
			comment.isSage = true
		} else if (email) {
			comment.authorEmail = email
		}
	}
	if (abuLike) {
		comment.abuLike = true
	}
	if (hasVoting) {
		comment.upvotes = post.likes
		comment.downvotes = post.dislikes
	}
	if (post.trip && !comment.authorRole) {
		comment.tripCode = post.trip
	}
	if (!isOpeningPost && post.op) {
		comment.isThreadAuthor = true
	}
	// `2ch.hk` returns poster countries on `/int/` board
	// in the form of an `<img/>` tag:
	// "icon": "<img hspace=\"3\" src=\"/flags/FI.png\" border=\"0\" />".
	// On `/po/` board flags are replaced with their aliases:
	// "icon": "<img hspace=\"3\" src=\"/icons/logos/ukr.png\" title=\"Украина\" border=\"0\" />".
	if (post.icon) {
		if (hasFlags) {
			const match = post.icon.match(/\/flags\/([A-Z]{2}).png/)
			if (match) {
				comment.authorCountry = match[1]
			} else {
				// Parse flags like `A1.png` which seems to mean
				// "Anonymizer" or "Proxy" or maybe "TOR Network".
				const match = post.icon.match(/\/flags\/(A\d).png/)
				if (match) {
					comment.authorCountry = 'ZZ'
				}
			}
		} else if (badges) {
			comment.authorBadgeUrl = post.icon.match(AUTHOR_ICON_URL_REGEXP)[1]
			comment.authorBadgeName = post.icon.match(AUTHOR_ICON_TITLE_REGEXP)[1]
			// Fix `2ch.hk` bug: `krym.png` has `.gif` extension.
			// https://2ch.hk/icons/logos/krym.gif
			// const authorBadgeIdRegExp = /\/icons\/logos\/([^\/]+).(png|gif)"
			// comment.authorBadgeId = match[1]
		}
	}
	return comment
}

const AUTHOR_ICON_URL_REGEXP = / src="([^"]+)"/
const AUTHOR_ICON_TITLE_REGEXP = / title="([^"]+)"/

/**
 * This is a reverse-engineered guess of
 * 2ch.hk's subject autogeneration algorithm.
 * For example, it's used in `/b/` and `/rf/`.
 * @param  {string}  subject
 * @param  {string}  comment
 * @return {Boolean}
 */
function isAutogeneratedSubject(subject, comment) {
	const commentText = comment.replace(/<br>/g, ' ').replace(/<.+?>/g, '')
	return commentText.indexOf(subject) === 0
}