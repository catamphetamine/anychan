{"version":3,"sources":["webpack://captchan/./node_modules/refractor/lang/stan.js"],"names":["stan","Prism","languages","comment","string","pattern","greedy","directive","lookbehind","alias","constraint","inside","expression","property","operator","punctuation","keyword","function","number","boolean","module","exports","displayName","aliases"],"mappings":"+FAKA,SAASA,EAAKC,GAEZA,EAAMC,UAAUF,KAAO,CACrBG,QAAS,yCACTC,OAAQ,CAGNC,QAAS,kCACTC,QAAQ,GAEVC,UAAW,CACTF,QAAS,yBACTG,YAAY,EACZC,MAAO,YAET,eAAgB,CACdJ,QAAS,qHACTG,YAAY,EACZC,MAAO,YAETC,WAAY,CACVL,QAAS,uDACTG,YAAY,EACZG,OAAQ,CACNC,WAAY,CACVP,QAAS,sDACTG,YAAY,EACZG,OAAQ,MAEVE,SAAU,sBACVC,SAAU,IACVC,YAAa,cAGjBC,QAAS,CACP,iTACA,mGAEFC,SAAU,uBACVC,OAAQ,+CACRC,QAAS,qBACTL,SAAU,8CACVC,YAAa,gBAEfd,EAAMC,UAAUF,KAAKU,WAAWC,OAAOC,WAAWD,OAChDV,EAAMC,UAAUF,KAhDpBoB,EAAOC,QAAUrB,EACjBA,EAAKsB,YAAc,OACnBtB,EAAKuB,QAAU","file":"react-syntax-highlighter_languages_refractor_stan.d58fbc990daa3ca00660.js","sourcesContent":["'use strict'\n\nmodule.exports = stan\nstan.displayName = 'stan'\nstan.aliases = []\nfunction stan(Prism) {\n  // https://mc-stan.org/docs/2_24/reference-manual/bnf-grammars.html\n  Prism.languages.stan = {\n    comment: /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/|#(?!include).*/,\n    string: {\n      // String literals can contain spaces and any printable ASCII characters except for \" and \\\n      // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals\n      pattern: /\"[\\x20\\x21\\x23-\\x5B\\x5D-\\x7E]*\"/,\n      greedy: true\n    },\n    directive: {\n      pattern: /^([ \\t]*)#include\\b.*/m,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'function-arg': {\n      pattern: /(\\b(?:algebra_solver|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect)\\s*\\(\\s*)[a-zA-Z]\\w*/,\n      lookbehind: true,\n      alias: 'function'\n    },\n    constraint: {\n      pattern: /(\\b(?:int|matrix|real|row_vector|vector)\\s*)<[^<>]*>/,\n      lookbehind: true,\n      inside: {\n        expression: {\n          pattern: /(=\\s*)\\S(?:\\S|\\s+(?!\\s))*?(?=\\s*(?:>$|,\\s*\\w+\\s*=))/,\n          lookbehind: true,\n          inside: null // see below\n        },\n        property: /\\b[a-z]\\w*(?=\\s*=)/i,\n        operator: /=/,\n        punctuation: /^<|>$|[,]/\n      }\n    },\n    keyword: [\n      /\\b(?:break|cholesky_factor_corr|cholesky_factor_cov|continue|corr_matrix|cov_matrix|data|else|for|functions|generated|if|in|increment_log_prob|int|matrix|model|ordered|parameters|positive_ordered|print|quantities|real|reject|return|row_vector|simplex|target|transformed|unit_vector|vector|void|while)\\b/, // these are functions that are known to take another function as their first argument.\n      /\\b(?:algebra_solver|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect)\\b/\n    ],\n    function: /\\b[a-z]\\w*(?=\\s*\\()/i,\n    number: /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:E[+-]?\\d+)?\\b/i,\n    boolean: /\\b(?:false|true)\\b/,\n    operator: /<-|\\.[*/]=?|\\|\\|?|&&|[!=<>+\\-*/]=?|['^%~?:]/,\n    punctuation: /[()\\[\\]{},;]/\n  }\n  Prism.languages.stan.constraint.inside.expression.inside =\n    Prism.languages.stan\n}\n"],"sourceRoot":""}