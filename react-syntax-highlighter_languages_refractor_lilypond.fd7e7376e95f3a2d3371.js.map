{"version":3,"sources":["webpack://captchan/./node_modules/refractor/lang/lilypond.js","webpack://captchan/./node_modules/refractor/lang/scheme.js"],"names":["refractorScheme","lilypond","Prism","register","schemeExpression","source","i","replace","languages","comment","pattern","RegExp","lookbehind","greedy","inside","scheme","alias","punctuation","rest","string","keyword","operator","number","ly","module","exports","displayName","aliases","symbol","character","builtin","boolean","function"],"mappings":"yGACA,IAAIA,EAAkB,EAAQ,MAI9B,SAASC,EAASC,GAChBA,EAAMC,SAASH,GACd,SAAWE,GAKV,IAJA,IAAIE,EAAmB,mGACpBC,OAGMC,EAAI,EAAGA,EADQ,EACeA,IACrCF,EAAmBA,EAAiBG,QAAQ,WAAW,WACrD,OAAOH,KAGXA,EAAmBA,EAAiBG,QAAQ,UAAW,UAAUF,QACjE,IAAIJ,EAAYC,EAAMM,UAAUP,SAAW,CACzCQ,QAAS,8BACT,kBAAmB,CACjBC,QAASC,OACP,8DAA8DN,OAAOE,QACnE,WACA,WACE,OAAOH,KAGX,KAEFQ,YAAY,EACZC,QAAQ,EACRC,OAAQ,CACNC,OAAQ,CACNL,QAAS,eACTE,YAAY,EACZI,MAAO,kBACPF,OAAQ,CACN,oBAAqB,CACnBJ,QAAS,iBACTG,QAAQ,EACRC,OAAQ,CACNG,YAAa,YACbhB,SAAU,CACRS,QAAS,UACTM,MAAO,oBACPF,OAAQ,QAIdI,KAAMhB,EAAMM,UAAUO,SAG1BE,YAAa,MAGjBE,OAAQ,CACNT,QAAS,oBACTG,QAAQ,GAEV,aAAc,CACZH,QAAS,mBACTE,YAAY,GAEdQ,QAAS,CACPV,QAAS,iBACTI,OAAQ,CACNG,YAAa,QAGjBI,SAAU,aACVJ,YAAa,CACXP,QAAS,uGACTE,YAAY,GAEdU,OAAQ,qBAEVrB,EAAS,mBAAmBa,OAAe,OAAEA,OAC3C,qBACAA,OAAiB,SAAEA,OAASb,EAC9BC,EAAMM,UAAUe,GAAKtB,EAzEtB,CA0EEC,GA/ELsB,EAAOC,QAAUxB,EACjBA,EAASyB,YAAc,WACvBzB,EAAS0B,QAAU,I,sBCCnB,SAASZ,EAAOb,GACdA,EAAMM,UAAUO,OAAS,CACvBN,QAAS,MACTU,OAAQ,CACNT,QAAS,oBACTG,QAAQ,GAEVe,OAAQ,CACNlB,QAAS,cACTG,QAAQ,GAEVgB,UAAW,CACTnB,QAAS,uCACTG,QAAQ,EACRG,MAAO,UAET,mBAAoB,CAElB,CACEN,QAAS,yBACTE,YAAY,GAEd,CACEF,QAAS,yBACTE,YAAY,IAGhBQ,QAAS,CACPV,QAAS,gPACTE,YAAY,GAEdkB,QAAS,CACPpB,QAAS,4NACTE,YAAY,GAEdU,OAAQ,CAgBNZ,QAAS,uVACTE,YAAY,GAEdmB,QAAS,CACPrB,QAAS,8BACTE,YAAY,GAEdS,SAAU,CACRX,QAAS,0CACTE,YAAY,GAEdoB,SAAU,CACRtB,QAAS,4BACTE,YAAY,GAEdK,YAAa,SArEjBO,EAAOC,QAAUV,EACjBA,EAAOW,YAAc,SACrBX,EAAOY,QAAU","file":"react-syntax-highlighter_languages_refractor_lilypond.fd7e7376e95f3a2d3371.js","sourcesContent":["'use strict'\nvar refractorScheme = require('./scheme.js')\nmodule.exports = lilypond\nlilypond.displayName = 'lilypond'\nlilypond.aliases = []\nfunction lilypond(Prism) {\n  Prism.register(refractorScheme)\n  ;(function (Prism) {\n    var schemeExpression = /\\((?:[^();\"#\\\\]|\\\\[\\s\\S]|;.*(?!.)|\"(?:[^\"\\\\]|\\\\.)*\"|#(?:\\{(?:(?!#\\})[\\s\\S])*#\\}|[^{])|<expr>)*\\)/\n      .source // allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions\n    // For some reason, this can't be 4\n    var recursivenessLog2 = 5\n    for (var i = 0; i < recursivenessLog2; i++) {\n      schemeExpression = schemeExpression.replace(/<expr>/g, function () {\n        return schemeExpression\n      })\n    }\n    schemeExpression = schemeExpression.replace(/<expr>/g, /[^\\s\\S]/.source)\n    var lilypond = (Prism.languages.lilypond = {\n      comment: /%(?:(?!\\{).*|\\{[\\s\\S]*?%\\})/,\n      'embedded-scheme': {\n        pattern: RegExp(\n          /(^|[=\\s])#(?:\"(?:[^\"\\\\]|\\\\.)*\"|[^\\s()\"]*(?:[^\\s()]|<expr>))/.source.replace(\n            /<expr>/g,\n            function () {\n              return schemeExpression\n            }\n          ),\n          'm'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          scheme: {\n            pattern: /^(#)[\\s\\S]+$/,\n            lookbehind: true,\n            alias: 'language-scheme',\n            inside: {\n              'embedded-lilypond': {\n                pattern: /#\\{[\\s\\S]*?#\\}/,\n                greedy: true,\n                inside: {\n                  punctuation: /^#\\{|#\\}$/,\n                  lilypond: {\n                    pattern: /[\\s\\S]+/,\n                    alias: 'language-lilypond',\n                    inside: null // see below\n                  }\n                }\n              },\n              rest: Prism.languages.scheme\n            }\n          },\n          punctuation: /#/\n        }\n      },\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': {\n        pattern: /(\\\\new\\s+)[\\w-]+/,\n        lookbehind: true\n      },\n      keyword: {\n        pattern: /\\\\[a-z][-\\w]*/i,\n        inside: {\n          punctuation: /^\\\\/\n        }\n      },\n      operator: /[=|]|<<|>>/,\n      punctuation: {\n        pattern: /(^|[a-z\\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\\d))|[_^]\\.?|[.!])|[{}()[\\]<>^~]|\\\\[()[\\]<>\\\\!]|--|__/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\/\\d+)?\\b/\n    })\n    lilypond['embedded-scheme'].inside['scheme'].inside[\n      'embedded-lilypond'\n    ].inside['lilypond'].inside = lilypond\n    Prism.languages.ly = lilypond\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = scheme\nscheme.displayName = 'scheme'\nscheme.aliases = []\nfunction scheme(Prism) {\n  Prism.languages.scheme = {\n    comment: /;.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true\n    },\n    symbol: {\n      pattern: /'[^()#'\\s]+/,\n      greedy: true\n    },\n    character: {\n      pattern: /#\\\\(?:[ux][a-fA-F\\d]+|[-a-zA-Z]+|\\S)/,\n      greedy: true,\n      alias: 'string'\n    },\n    'lambda-parameter': [\n      // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30\n      {\n        pattern: /(\\(lambda\\s+)[^()'\\s]+/,\n        lookbehind: true\n      },\n      {\n        pattern: /(\\(lambda\\s+\\()[^()']+/,\n        lookbehind: true\n      }\n    ],\n    keyword: {\n      pattern: /(\\()(?:define(?:-library|-macro|-syntax|-values)?|defmacro|(?:case-)?lambda|let(?:(?:\\*|rec)?(?:-values)?|-syntax|rec-syntax)|else|if|cond|begin|delay(?:-force)?|parameterize|guard|set!|(?:quasi-)?quote|syntax-(?:case|rules))(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    builtin: {\n      pattern: /(\\()(?:(?:cons|car|cdr|list|call-with-current-continuation|call\\/cc|append|abs|apply|eval)\\b|null\\?|pair\\?|boolean\\?|eof-object\\?|char\\?|procedure\\?|number\\?|port\\?|string\\?|vector\\?|symbol\\?|bytevector\\?)(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    number: {\n      // This pattern (apart from the lookarounds) works like this:\n      //\n      // Decimal numbers\n      // <dec real>       := \\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+\n      // <dec complex>    := <dec real>(?:[+-]<dec real>i)?|<dec real>i\n      // <dec prefix>     := (?:#d(?:#[ei])?|#[ei](?:#d)?)?\n      // <dec number>     := <dec prefix>[+-]?<complex>\n      //\n      // Binary, octal, and hexadecimal numbers\n      // <b.o.x. real>    := [\\da-fA-F]+(?:\\/[\\da-fA-F]+)?\n      // <b.o.x. complex> := <b.o.x. real>(?:[+-]<b.o.x. real>i)?|<b.o.x. real>i\n      // <b.o.x. prefix>  := #[box](?:#[ei])?|#[ei](?:#[box])?\n      // <b.o.x. number>  := <b.o.x. prefix>[+-]?<b.o.x. complex>\n      //\n      // <number>         := <dec number>|<b.o.x. number>\n      pattern: /(^|[\\s()])(?:(?:#d(?:#[ei])?|#[ei](?:#d)?)?[+-]?(?:(?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)(?:[+-](?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)i)?|(?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)i)|(?:#[box](?:#[ei])?|#[ei](?:#[box])?)[+-]?(?:[\\da-fA-F]+(?:\\/[\\da-fA-F]+)?(?:[+-][\\da-fA-F]+(?:\\/[\\da-fA-F]+)?i)?|[\\da-fA-F]+(?:\\/[\\da-fA-F]+)?i))(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    boolean: {\n      pattern: /(^|[\\s()])#[ft](?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    operator: {\n      pattern: /(\\()(?:[-+*%\\/]|[<>]=?|=>?)(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    function: {\n      pattern: /(\\()[^()'\\s]+(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    punctuation: /[()']/\n  }\n}\n"],"sourceRoot":""}